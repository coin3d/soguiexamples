# 1 "extselection.cpp.in"
/**************************************************************************\
 *
 *  This file is part of a set of example programs for the Coin library.
 *  Copyright (C) 2000-2002 by Systems in Motion. All rights reserved.
 *
 *                   <URL:http://www.coin3d.org>
 *
 *  This sourcecode can be redistributed and/or modified under the
 *  terms of the GNU General Public License version 2 as published by
 *  the Free Software Foundation. See the file COPYING at the root
 *  directory of the distribution for more details.
 *
 *  As a special exception, all sourcecode of the demo examples can be
 *  used for any purpose for licensees of the Coin Professional
 *  Edition License, without the restrictions of the GNU GPL. See our
 *  web pages for information about how to acquire a Professional Edition
 *  License.
 *
 *  Systems in Motion, <URL:http://www.sim.no>, <mailto:support@sim.no>
 *
\**************************************************************************/

#include <Inventor/@Gui@/So@Gui@.h>
#include <Inventor/@Gui@/viewers/So@Gui@ExaminerViewer.h>
#include <Inventor/nodes/SoSeparator.h>

// This example uses SoExtSelection, SoPolygonOffset and
// SbBSPTree. All of these are missing from SGI Inventor. TGS Inventor
// has the first two, but is missing SbBSPTree.
#ifndef __COIN__

#include <Inventor/nodes/SoText3.h>
#include <stdio.h>


int
main(int argc, char ** argv)
{
  @WIDGET@ window = So@Gui@::init(argv[0]);
  if (window == NULL) exit(1);

  SoSeparator * root = new SoSeparator;
  root->ref();

  const char * info[] = {
    "This example depends on Coin-specific",
    "extensions. This is just an informational",
    "message and not the real functionality",
    "of the example."
  };

  SoText3 * msg = new SoText3;
  msg->justification = SoText3::CENTER;
  msg->string.setValues(0, sizeof(info) / sizeof(const char *), info);
  root->addChild(msg);

  So@Gui@ExaminerViewer * viewer = new So@Gui@ExaminerViewer(window);
  viewer->setSceneGraph(root);
  viewer->show();

  So@Gui@::show(window);
  So@Gui@::mainLoop();

  delete viewer;
  root->unref();

  return 1;
}

#else // __COIN__

#include <Inventor/nodes/SoTranslation.h>
#include <Inventor/nodes/SoExtSelection.h>
#include <Inventor/nodes/SoCamera.h>
#include <Inventor/nodes/SoIndexedLineSet.h>
#include <Inventor/nodes/SoCoordinate3.h>
#include <Inventor/nodes/SoLightModel.h>
#include <Inventor/nodes/SoBaseColor.h>
#include <Inventor/actions/SoSearchAction.h>
#include <Inventor/SoInput.h>
#include <Inventor/nodes/SoEventCallback.h>
#include <Inventor/nodes/SoTransform.h>
#include <Inventor/nodes/SoPolygonOffset.h>
#include <Inventor/nodes/SoDrawStyle.h>
#include <Inventor/events/SoKeyboardEvent.h>
#include <Inventor/manips/SoTrackballManip.h>
#include <Inventor/nodes/SoCone.h>
#include <Inventor/actions/SoCallbackAction.h>
#include <Inventor/sensors/SoIdleSensor.h>
#include <assert.h>
#include <Inventor/SoInput.h>
#include <Inventor/SoOutput.h>
#include <Inventor/actions/SoBoxHighlightRenderAction.h>
#include <Inventor/SoPrimitiveVertex.h>
#include <Inventor/SbBSPTree.h>
#include <Inventor/details/SoFaceDetail.h>
#include <Inventor/details/SoPointDetail.h>

#include <string.h>

// *************************************************************************


// This is not how it should be done, since triangles might be
// selected multiple times. We just wrote this piece of crap for demo
// purposes.

SbBSPTree mybsptree;
SbList <int32_t> myidxlist;

SoCoordinate3 * mycoords = NULL;
SoIndexedLineSet * mylineset = NULL;

int trianglecounter;
int linecounter;
int pointcounter;

SoExtSelection * selection;

static void
start_callback(void * userdata, SoSelection * sel)
{
  trianglecounter = 0;
  linecounter = 0;
  if (sel->policy.getValue() == SoSelection::SINGLE ||
      (sel->policy.getValue() == SoSelection::SHIFT && !((SoExtSelection*)sel)->wasShiftDown())) {
    mybsptree.clear();
    myidxlist.truncate(0);

    // This line is very important or the 'selection-lines' will be selected during the next selection as
    // a part of the original object.
    mylineset->coordIndex.setNum(0);
  }
}

static void
finish_callback(void * userdata, SoSelection * sel)
{
  int n = mybsptree.numPoints();
  mycoords->point.setNum(n);
  memcpy(mycoords->point.startEditing(), mybsptree.getPointsArrayPtr(), n*sizeof(SbVec3f));
  mycoords->point.finishEditing();

  n = myidxlist.getLength();
  mylineset->coordIndex.setNum(n);
  memcpy(mylineset->coordIndex.startEditing(), myidxlist.getArrayPtr(), n*sizeof(int32_t));
  mylineset->coordIndex.finishEditing();
}

static SbBool 
lineCB(void * userdata, 
       SoCallbackAction * action, 
       const SoPrimitiveVertex * v1, 
       const SoPrimitiveVertex * v2)
{
  const SbMatrix & mm = action->getModelMatrix();

  ++linecounter;

  SbVec3f vec1 = v1->getPoint();
  SbVec3f vec2 = v2->getPoint();
  
  mm.multVecMatrix(v1->getPoint(),vec1);
  mm.multVecMatrix(v2->getPoint(),vec2);

  myidxlist.append(mybsptree.addPoint(vec1)); // Ugly hack. A 'line' must have 3 points...
  myidxlist.append(mybsptree.addPoint(vec2));
  myidxlist.append(mybsptree.addPoint(vec1));
 
  myidxlist.append(-1);

  return FALSE;
}

static SbBool 
pointCB(void * userdata, 
        SoCallbackAction * action, 
        const SoPrimitiveVertex * v1)
{
  const SbMatrix & mm = action->getModelMatrix();

  ++pointcounter;

  SbVec3f vec1 = v1->getPoint();
  SbVec3f vec2 = v1->getPoint();

  mm.multVecMatrix(v1->getPoint(),vec1);
  mm.multVecMatrix(v1->getPoint(),vec2);

  vec2[0] += .1;
  vec2[1] += .1;
  vec2[2] += .1;

  myidxlist.append(mybsptree.addPoint(vec1)); // Ugly hack. A 'point' must have 3 points...
  myidxlist.append(mybsptree.addPoint(vec2));
  myidxlist.append(mybsptree.addPoint(vec1));
 
  myidxlist.append(-1);

  return FALSE;
}

static SbBool 
triangleCB(void * userdata, 
           SoCallbackAction * action, 
           const SoPrimitiveVertex * v1, 
           const SoPrimitiveVertex * v2, 
           const SoPrimitiveVertex * v3)
{

  // FIXME: need to test if face has already been added
  const SbMatrix & mm = action->getModelMatrix();

  SbVec3f op;
  SbVec3f wp;

  ++trianglecounter;

  const SoDetail * detail = v1->getDetail();
  // if not face, select entire object
  if(!detail || !detail->isOfType(SoFaceDetail::getClassTypeId())){
    return TRUE;
  }

  const SoFaceDetail * fd = (const SoFaceDetail*) detail;
  assert(fd->isOfType(SoFaceDetail::getClassTypeId()));
  assert(fd);
  const SoPointDetail * pd;

  for (int i = 0; i <= fd->getNumPoints(); i++) {
    pd = fd->getPoint(i%fd->getNumPoints());
    assert(pd);
    assert(pd->getCoordinateIndex() < action->getNumCoordinates());
    op = action->getCoordinate3(pd->getCoordinateIndex());
    mm.multVecMatrix(op, wp);
    myidxlist.append(mybsptree.addPoint(wp));
  }
  
  myidxlist.append(-1);
  return FALSE;
}

static SoSeparator * 
make_line_sg(void)
{
  SoSeparator * sep = new SoSeparator;
  SoLightModel * lm = new SoLightModel;
  lm->model = SoLightModel::BASE_COLOR;
  sep->addChild(lm);
  SoBaseColor * col = new SoBaseColor;
  col->rgb = SbColor(1.0f, 0.0f, 0.0f);
  sep->addChild(col);
  SoDrawStyle * ds = new SoDrawStyle;
  ds->lineWidth = 2;
  sep->addChild(ds);

  mycoords = new SoCoordinate3;
  mylineset = new SoIndexedLineSet;
  sep->addChild(mycoords);
  sep->addChild(mylineset);
  return sep;
}

// Print a quick instructions notice on stdout.
void
show_instructions( void )
{
  (void)fprintf(stdout, 
                "\nThis example program demonstrates the use of the SoExtSelection node type.\n"
                "\nQuick instructions:\n\n"
                "  * draw a polygon by selecting vertices with the left mouse button\n"
                "  * terminate polygon either by selecting the same point twice,\n"
                "    or by clicking the right mouse button.\n"
                "  * hold SHIFT to avoid clearing selection when selecting new triangles\n"
                "  * hit ESC to toggle back and forth to view mode\n\n"
                "  * Toggle keys:\n"
                "     'v' = VISIBLE_SHAPES selection\n"
                "     'a' = ALL_SHAPES selection\n"
                "     'f' = FULL mode\n"
                "     'p' = PART mode\n"
                "     '1' = FULL_BBOX selection\n"
                "     '2' = PART_BBOX selection\n"
                "     'l' = Lasso mode\n"
                "     'r' = Rectangle mode\n"
                "     'n' = Pick/NoLasso mode\n"
                "     's' = Single selection\n"
                "     'h' = Shift selection\n",
                "     't' = toggle selection \n\n");
}

void
event_cb(void * userdata, SoEventCallback * node)
{
  const SoEvent * event = node->getEvent();

  if (SO_KEY_PRESS_EVENT(event, V)) {
    selection->lassoMode = SoExtSelection::VISIBLE_SHAPES;
    fprintf(stdout,"VISIBLE_SHAPES mode\n");
  }
  if (SO_KEY_PRESS_EVENT(event, A)) {
    selection->lassoMode = SoExtSelection::ALL_SHAPES;
    fprintf(stdout,"ALL_SHAPES mode\n");
  }
  if (SO_KEY_PRESS_EVENT(event, F)) {
    selection->lassoPolicy = SoExtSelection::FULL;
    fprintf(stdout,"FULL mode\n");
  }
  if (SO_KEY_PRESS_EVENT(event, P)) {
    selection->lassoPolicy = SoExtSelection::PART;
    fprintf(stdout,"PART mode\n");
  }
  if (SO_KEY_PRESS_EVENT(event, NUMBER_1)) {
    selection->lassoPolicy = SoExtSelection::FULL_BBOX;
    fprintf(stdout,"FULL_BBOX mode\n");
  }
  if (SO_KEY_PRESS_EVENT(event, NUMBER_2)) {
    selection->lassoPolicy = SoExtSelection::PART_BBOX;
    fprintf(stdout,"PART_BBOX mode\n");
  }
  if (SO_KEY_PRESS_EVENT(event, L)) {
    selection->lassoType = SoExtSelection::LASSO;
    fprintf(stdout,"Lasso mode\n");
  }
  if (SO_KEY_PRESS_EVENT(event, R)) {
    selection->lassoType = SoExtSelection::RECTANGLE;
    fprintf(stdout,"Rectangle mode\n");
  }
  if (SO_KEY_PRESS_EVENT(event, N)) {
    selection->lassoType = SoExtSelection::NOLASSO;
    fprintf(stdout,"NoLasso mode\n");
  }
  if (SO_KEY_PRESS_EVENT(event, S)) {
    selection->policy = SoSelection::SINGLE;
    fprintf(stdout,"Single selection\n");
  }
  if (SO_KEY_PRESS_EVENT(event, H)) {
    selection->policy = SoSelection::SHIFT;
    fprintf(stdout,"Shift selection\n");
  }
  if (SO_KEY_PRESS_EVENT(event, T)) {
    selection->policy = SoSelection::TOGGLE;
    // FIXME: should write up the necessary code in this example to
    // make toggle work for polygon/line/point primitive sets
    // aswell. 20020808 mortene.
    fprintf(stdout,"Toggle selection (note: only works for full shapes)\n");
  }
}


int
main(int argc, char ** argv)
{
  if (argc != 2) {
    (void) fprintf(stderr,"\nSpecify an Inventor file as argument.\n");
    return -1;
  }

  @WIDGET@ window = So@Gui@::init( argv[0] );

  So@Gui@ExaminerViewer * ex1 = new So@Gui@ExaminerViewer( window );

  ex1->setBackgroundColor(SbColor(0.5, 0.5, 0.7));
  
  SoInput input;
  SbBool ok = input.openFile(argv[1]);
  if (!ok) {
    (void) fprintf(stderr, "Unable to open file: %s\n", argv[1]);
    return -1;
  }

  SoSeparator *root = SoDB::readAll(&input); 
  
  if (root == NULL) {
    (void) fprintf(stderr, "Unable to read file: %s\n", argv[1]);
    return -1;
  }

  show_instructions();

  SoPolygonOffset * po = new SoPolygonOffset;
  po->styles = SoPolygonOffset::FILLED;
  po->factor = 1.0f;
  po->units = 1.0f;
  po->on = TRUE;
  root->insertChild(po, 0);



  selection = new SoExtSelection;
  selection->ref();
  selection->lassoPolicy = SoExtSelection::PART;
  selection->policy = SoSelection::SHIFT;
  selection->lassoType = SoExtSelection::LASSO;
  selection->lassoMode = SoExtSelection::ALL_SHAPES;

  selection->setLassoColor(SbColor(0.9f,0.7f,0.2f));
  selection->setLassoWidth(3);
  selection->setOverlayLassoPattern(0xf0f0);  // 0011 0011 0011 0011
  selection->animateOverlayLasso(FALSE);
  selection->addStartCallback(start_callback);
  selection->addFinishCallback(finish_callback);
  selection->setTriangleFilterCallback(triangleCB, NULL);
  selection->setLineSegmentFilterCallback(lineCB, NULL);
  selection->setPointFilterCallback(pointCB, NULL);

  
  SoEventCallback * cb = new SoEventCallback;
  cb->addEventCallback(SoKeyboardEvent::getClassTypeId(),
                       event_cb, NULL);
  root->insertChild(cb, 0);
  
  selection->addChild(root);
  

  SoSeparator * newroot = new SoSeparator;
  newroot->ref();
  newroot->addChild(selection);
  SoSeparator * overlaylines = make_line_sg();
  newroot->addChild(overlaylines);

  ex1->setSceneGraph(newroot);
  ex1->setTransparencyType(SoGLRenderAction::SORTED_OBJECT_BLEND);
  ex1->setGLRenderAction(new SoBoxHighlightRenderAction(SbViewportRegion()));
  ex1->setViewing(FALSE);

  SoSearchAction search;
  search.setType(SoExtSelection::getClassTypeId());
  search.setFind(SoSearchAction::TYPE);
  search.setInterest(SoSearchAction::ALL);
  search.apply(root);
  SoPathList & pathlist2 = search.getPaths();


  if(pathlist2.getLength() > 0) {
    (void) fprintf(stderr,
                   "ERROR: You cannot have two ExtSelection nodes beneath each other\n"
                   "in the same scenegraph!\n\n");
    return 0;
  }

  // Just check if we can draw a sensible set of overlay lines --
  // multiple cameras makes this very hard, so it's not supported in
  // this example program.

  search.setType(SoCamera::getClassTypeId());
  search.setFind(SoSearchAction::TYPE);
  search.setInterest(SoSearchAction::ALL);
  search.apply(root);
  SoPathList & pathlist = search.getPaths();
  if(pathlist.getLength() > 1) {
    (void) fprintf(stderr,
                   "WARNING: there is more than 1 camera in the loaded\n"
                   "scenegraph -- overlay lines for selection might come\n"
                   "out wrong!\n");

  }


  // Make sure the overlay lines we render are within the same camera
  // scope as the actual geometry from the input file.
  overlaylines->insertChild(ex1->getCamera(), 0);
  
  ex1->show();
  So@Gui@::show( window );

  So@Gui@::mainLoop();
  delete ex1;

  selection->unref();
  return 0;
} // main()

#endif // __COIN__

/**************************************************************************\
 *
 *  This file is part of a set of example programs for the Coin library.
 *  Copyright (C) 2000-2002 by Systems in Motion. All rights reserved.
 *
 *                   <URL:http://www.coin3d.org>
 *
 *  This sourcecode can be redistributed and/or modified under the
 *  terms of the GNU General Public License version 2 as published by
 *  the Free Software Foundation. See the file COPYING at the root
 *  directory of the distribution for more details.
 *
 *  As a special exception, all sourcecode of the demo examples can be
 *  used for any purpose for licensees of the Coin Professional
 *  Edition License, without the restrictions of the GNU GPL. See our
 *  web pages for information about how to acquire a Professional Edition
 *  License.
 *
 *  Systems in Motion, <URL:http://www.sim.no>, <mailto:support@sim.no>
 *
\**************************************************************************/

#include <Inventor/@Gui@/So@Gui@.h>
#include <Inventor/@Gui@/viewers/So@Gui@ExaminerViewer.h>
#include <Inventor/SoPickedPoint.h>
#include <Inventor/actions/SoRayPickAction.h>
#include <Inventor/events/SoMouseButtonEvent.h>
#include <Inventor/nodes/SoCone.h>
#include <Inventor/nodes/SoCube.h>
#include <Inventor/nodes/SoEventCallback.h>
#include <Inventor/nodes/SoPerspectiveCamera.h>
#include <Inventor/nodes/SoSeparator.h>

// *************************************************************************

// Calculates azimuth angle for the "directionvec" input argument. An
// azimuth angle is the angle of a vector versus the direction of
// compass north, where 0° means the input vector points straight
// north, 90° is east, 180° south and 270° is west.
static float
azimuth_angle(SbVec3f north, SbVec3f east, SbVec3f directionvec)
{
  // Make compass plane.
  SbPlane compassplane(SbVec3f(0, 0, 0), north, east);

  // Project input vector into the compass plane.
  float d = compassplane.getDistance(directionvec);
  directionvec = directionvec - (compassplane.getNormal() * d);

  // Find absolute angle in the [0, PI] range versus the north vector.
  directionvec.normalize();
  north.normalize();
  float angle = acos(north.dot(directionvec));

  // Check if the input argument vector is pointing to the "west side"
  // of the north-south axis, and if so, correct the absolute angle.
  if (directionvec.dot(east) < 0.0f) { angle = M_PI + (M_PI - angle); }

  return angle;
}

// *************************************************************************

// Calculates elevation angle of the "directionvec" argument versus
// the given ground plane. The angle returned is in the range [0,PI]
// for a vector pointing "up" versus the plane, and in the range
// <0,-PI> for a vector pointing into the ground (ie in the opposite
// direction of the ground plane's normal vector).
static float
elevation_angle(SbPlane groundplane, SbVec3f directionvec)
{
  // Project input vector into a mirrored vector in the ground plane.
  float d = groundplane.getDistance(directionvec);
  SbVec3f groundvec = directionvec - (groundplane.getNormal() * d);

  // Find absolute angle in the [0, PI] range versus the groundplane.
  directionvec.normalize();
  groundvec.normalize();
  float angle = acos(groundvec.dot(directionvec));

  // Check if the input argument vector is pointing into the ground,
  // and if so, correct the absolute angle.
  SbVec3f n = groundplane.getNormal();
  n.normalize();
  if (directionvec.dot(n) < 0.0f) { angle = -angle; }

  return angle;
}

// *************************************************************************

static void
event_cb(void * ud, SoEventCallback * n)
{
  const SoMouseButtonEvent * mbe = (SoMouseButtonEvent *)n->getEvent();

  if (mbe->getButton() == SoMouseButtonEvent::BUTTON1 &&
      mbe->getState() == SoButtonEvent::DOWN) {
    So@Gui@ExaminerViewer * viewer = (So@Gui@ExaminerViewer *)ud;

    SoRayPickAction rp(viewer->getViewportRegion());
    rp.setPoint(mbe->getPosition());
    rp.apply(viewer->getSceneManager()->getSceneGraph());

    SoPickedPoint * point = rp.getPickedPoint();
    if (point == NULL) {
      (void)fprintf(stderr, "\n** miss! **\n\n");
      return;
    }

    n->setHandled();

    (void)fprintf(stdout, "\n");

    SbVec3f v = point->getPoint();
    SbVec3f nv = point->getNormal();
    (void)fprintf(stdout, "point=<%f, %f, %f>, normvec=<%f, %f, %f>\n",
                  v[0], v[1], v[2], nv[0], nv[1], nv[2]);

    const SoCamera * camera = viewer->getCamera();
    SbVec3f camerapos = viewer->getCamera()->position.getValue();
    SbVec3f hitvec = v - camerapos;
    (void)fprintf(stdout, "hitvec=<%f, %f, %f>\n", hitvec[0], hitvec[1], hitvec[2]);

    // Find and print the azimuth angle of the vector from the camera
    // position to the point that was picked.
    const SbVec3f NORTH(0, 0, -1);
    const SbVec3f EAST(1, 0, 0);
    float azimuth = azimuth_angle(NORTH, EAST, hitvec);
    (void)fprintf(stdout, "Azimuth angle: %f\n", azimuth * 180.0f / M_PI);

    // Find and print the elevation angle of the vector from the
    // camera position to the point that was picked.
    const SbPlane GROUNDPLANE(SbVec3f(0, 1, 0), 0);
    float elevation = elevation_angle(GROUNDPLANE, hitvec);
    (void)fprintf(stdout, "Elevation angle: %f\n", elevation * 180.0f / M_PI);
  }
}

// *************************************************************************

static const char * scene_iv =
{
  "#Inventor V2.1 ascii\n\n"
  ""
  "Separator {"
  "  Cone { }"
  "  Separator {"
  "    Translation { translation -1.5 0 0 }"
  "    Rotation { rotation 1 0 0  -1.2 }"
  "    Scale { scaleFactor 0.05 0.05 0.05 }"
  "    Text3 { string \"W\"  parts ALL }"
  "  }"
  "  Separator {"
  "    Translation { translation 1.5 0 0 }"
  "    Rotation { rotation 1 0 0  -1.2 }"
  "    Scale { scaleFactor 0.05 0.05 0.05 }"
  "    Text3 { string \"E\"  parts ALL }"
  "  }"
  "  Separator {"
  "    Translation { translation 0 0 -1.5 }"
  "    Rotation { rotation 1 0 0  -1.2 }"
  "    Scale { scaleFactor 0.05 0.05 0.05 }"
  "    Text3 { string \"N\"  parts ALL }"
  "  }"
  "  Separator {"
  "    Translation { translation 0 0 1.5 }"
  "    Rotation { rotation 1 0 0  -1.2 }"
  "    Scale { scaleFactor 0.05 0.05 0.05 }"
  "    Text3 { string \"S\"  parts ALL }"
  "  }"
  "}"
};

// *************************************************************************

int
main(int argc, char ** argv)
{
  @WIDGET@ window = So@Gui@::init(argv[0]);

  So@Gui@ExaminerViewer * viewer = new So@Gui@ExaminerViewer(window);

  SoSeparator * sep = new SoSeparator;
  sep->ref();

  SoEventCallback * ecb = new SoEventCallback;
  ecb->addEventCallback(SoMouseButtonEvent::getClassTypeId(), event_cb, viewer);
  sep->addChild(ecb);

  SoInput in;
  in.setBuffer((void *)scene_iv, strlen(scene_iv));
  SoSeparator * r = SoDB::readAll(&in);
  assert(r);
  sep->addChild(r);

  viewer->setSceneGraph(sep);
  viewer->show();
  So@Gui@::show(window);

  So@Gui@::mainLoop();

  delete viewer;
  sep->unref();
  return 0;
}

// *************************************************************************

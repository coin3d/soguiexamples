/**************************************************************************\
 *
 *  This file is part of a set of example programs for the Coin library.
 *  Copyright (C) 2000-2002 by Systems in Motion. All rights reserved.
 *
 *                   <URL:http://www.coin3d.org>
 *
 *  This sourcecode can be redistributed and/or modified under the
 *  terms of the GNU General Public License version 2 as published by
 *  the Free Software Foundation. See the file COPYING at the root
 *  directory of the distribution for more details.
 *
 *  As a special exception, all sourcecode of the demo examples can be
 *  used for any purpose for licensees of the Coin Professional
 *  Edition License, without the restrictions of the GNU GPL. See our
 *  web pages for information about how to acquire a Professional Edition
 *  License.
 *
 *  Systems in Motion, <URL:http://www.sim.no>, <mailto:support@sim.no>
 *
\**************************************************************************/

// This game is an implementation of a 3D tetris that I
// played myself for the first time around 1990.
// This version is rather lacking as a professional
// game. No topscore, no introductional screen,
// no possibility to change options, whatever those
// should be.
// Feel free to make it better, whoever wants to try.
// I doubt I'll ever do anything more on this game
// again.

// If somebody wants to know about some of the stranger
// undocumented things i've done, please mail
// me at larsivi@sim.no


#include <Inventor/@Gui@/So@Gui@.h>
#include <Inventor/@Gui@/viewers/So@Gui@ExaminerViewer.h>
#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/nodes/SoDirectionalLight.h>
#include <Inventor/nodes/SoSpotLight.h>
#include <Inventor/nodes/SoPerspectiveCamera.h>
#include <Inventor/nodes/SoEventCallback.h>
#include <Inventor/nodes/SoCube.h>
#include <Inventor/nodes/SoMaterial.h>
#include <Inventor/nodes/SoTranslation.h>
#include <Inventor/nodes/SoCallback.h>
#include <Inventor/events/SoKeyboardEvent.h>
#include <Inventor/nodes/SoText2.h>
#include <Inventor/elements/SoViewportRegionElement.h>
#include <Inventor/sensors/SoTimerSensor.h>

#include <Inventor/fields/SoSFString.h>

SbBool room[4][4][14];
SoSeparator * roomblocks[4][4][14];
SoMaterial * roommaterials[4][4][14];
short piece[4][3];
short piecet;
SoMaterial * piecematerial;
int lines1 = 0;
SbString lines2 ;
SoSFString * lines3;

SoSeparator * create_room()
{
  piecematerial = new SoMaterial;
  piecematerial->ref();
  lines3 = new SoSFString;
  lines2 = SbString(lines1);
  lines3->setValue(lines2.getString());

  SoSeparator * roomsep = new SoSeparator;

  SoMaterial *mat = new SoMaterial;
  mat->diffuseColor.setValue(0.9,0.5,0.3);
  mat->specularColor.setValue(0.51,0.53,0.08);
  mat->ambientColor.setValue(0.0, 1.0, 0.1);

  roomsep->addChild(mat);

  SoCube *floor = new SoCube;
  floor->height.setValue(0.2);
  floor->width.setValue(4);
  floor->depth.setValue(0.5);

  roomsep->addChild(floor);

  SbVec3f move;
  SoTranslation *trans = new SoTranslation;
  move.setValue(0,0,4.5);
  trans->translation.setValue(move);

  roomsep->addChild(trans);
  roomsep->addChild(floor);

  move.setValue(-2.25, 0, -2.25);
  trans = new SoTranslation;
  trans->translation.setValue(move);

  floor = new SoCube;
  floor->height.setValue(0.2);
  floor->width.setValue(0.5);
  floor->depth.setValue(4);

  roomsep->addChild(trans);
  roomsep->addChild(floor);

  move.setValue(4.5, 0, 0);
  trans = new SoTranslation;
  trans->translation.setValue(move);

  roomsep->addChild(trans);
  roomsep->addChild(floor);

  move.setValue(-3.75, 0, -1.5);

  floor = new SoCube;
  floor->height.setValue(0.2);
  floor->width.setValue(1);
  floor->depth.setValue(1);

  for (int j=0;j<4;j++) {
    for (int i=0;i<4;i++) {
      trans = new SoTranslation;
      trans->translation.setValue(move);
      roomsep->addChild(trans);
      roomsep->addChild(floor);
      move.setValue(1,0,0);
    }
    move.setValue(-3,0,1);
  }

  move.setValue(0.625, 7.5, 0.625);
  trans = new SoTranslation;
  trans->translation.setValue(move);
  roomsep->addChild(trans);

  mat = new SoMaterial;
  mat->diffuseColor.setValue(0.2,0.2,0.2);
  mat->specularColor.setValue(0.2,0.53,0.78);
  mat->ambientColor.setValue(0.0, 0.0, 1.0);

  roomsep->addChild(mat);

  SoCube *corner = new SoCube;
  corner->height.setValue(15.2);
  corner->width.setValue(0.25);
  corner->depth.setValue(0.25);

  roomsep->addChild(corner);

  move.setValue(0, 0, -4.25);
  trans = new SoTranslation;
  trans->translation.setValue(move);
  roomsep->addChild(trans);
  roomsep->addChild(corner);

  move.setValue(-4.25, 0, 0);
  trans = new SoTranslation;
  trans->translation.setValue(move);
  roomsep->addChild(trans);
  roomsep->addChild(corner);

  move.setValue(0, 0, 4.25);
  trans = new SoTranslation;
  trans->translation.setValue(move);
  roomsep->addChild(trans);
  roomsep->addChild(corner);

  return roomsep;
}

void setViewportCB(void *data, SoAction *action)
{
  if (action->isOfType(SoGLRenderAction::getClassTypeId())) {
    SbViewportRegion curVP, newVP;
    curVP = ((SoGLRenderAction*)action)->getViewportRegion();
    newVP = curVP;
    newVP.setViewport( -0.07, 0.015, 0.45, 0.35);
    SoState *state = action->getState();
    SoViewportRegionElement::set( state, newVP );
  }
}

SoSeparator *
init_game()
{

  SoCube *block = new SoCube;
  block->height.setValue(1);
  block->width.setValue(1);
  block->depth.setValue(1);

  SoTranslation *trans;
  SbVec3f move;

  SoSeparator *blocksep = new SoSeparator;

  for(int i = 0; i < 14; i++){
    for(int j = 0; j < 4; j++){
      for(int k = 0; k < 4; k++){
        room[k][j][i] = FALSE;

        move.setValue(-1.5 + k, 0.5 + i, 0.75 + j);
        trans = new SoTranslation;
        trans->translation.setValue(move);

        roommaterials[k][j][i] = new SoMaterial;
        roommaterials[k][j][i]->diffuseColor.setValue(0.2,0.2,0.2);
        roommaterials[k][j][i]->specularColor.setValue(0.2,0.53,0.78);
        roommaterials[k][j][i]->transparency.setValue(1.0);

        roomblocks[k][j][i] = new SoSeparator;
        roomblocks[k][j][i]->addChild(roommaterials[k][j][i]);
        roomblocks[k][j][i]->addChild(trans);
        roomblocks[k][j][i]->addChild(block);
        blocksep->addChild(roomblocks[k][j][i]);

      }
    }
  }

  return blocksep;

}

SbBool
lower_piece()
{
  SbBool ok = TRUE;

  for(int i = 0; i < 4; i++){
    short x = piece[i][0];
    short y = piece[i][1];
    short z = piece[i][2];

    if(room[x][y][z-1] || z < 1){
      ok = FALSE;
      break;
    }
  }
  if(ok){
    int i;
    for(i = 0; i < 4; i++){
      roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
    }

    for(i = 0; i < 4; i++){
      roommaterials[piece[i][0]][piece[i][1]][piece[i][2]-1]->ambientColor = piecematerial->ambientColor;
      roommaterials[piece[i][0]][piece[i][1]][piece[i][2]-1]->transparency.setValue(0.0);

      piece[i][2] -= 1;

    }
  }
  else{
    for(int i = 0; i < 4; i++){
      room[piece[i][0]][piece[i][1]][piece[i][2]] = TRUE;
    }
  }
  return ok;
}

SbBool
translate_piece(short way)
{
  SbBool ok = TRUE;
  int i = 0;

  switch(way){
  case 0:
    for(i = 0; i < 4; i++){
      if(ok = (piece[i][0]-1 > -1)){
        if(!(ok = !room[piece[i][0] - 1][piece[i][1]][piece[i][2]])) break;
      }
      if(!ok) break;
    }
    if(ok){
      for(i = 0; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
        piece[i][0] -= 1;
      }
      for(i = 0; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
      }
    }
    break;
  case 1:
    for(i = 0; i < 4; i++){
      if(ok = (piece[i][0]+1 < 4)){
        if(!(ok = !room[piece[i][0] + 1][piece[i][1]][piece[i][2]])) break;
      }
      if(!ok) break;
    }
    if(ok){
      for(i = 0; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
        piece[i][0] += 1;
      }
      for(i = 0; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
      }
    }
    break;
  case 2:
    for(i = 0; i < 4; i++){
      if(ok = (piece[i][1]-1 > -1)){
        if(!(ok = !room[piece[i][0]][piece[i][1] - 1][piece[i][2]])) break;
      }
      if(!ok) break;
    }
    if(ok){
      for(i = 0; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
        piece[i][1] -= 1;
      }
      for(i = 0; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
      }
    }
    break;
  case 3:
    for(i = 0; i < 4; i++){
      if(ok = (piece[i][1]+1 < 4)){
        if(!(ok = !room[piece[i][0]][piece[i][1] + 1][piece[i][2]])) break;
      }
      if(!ok) break;
    }
    if(ok){
      for(i = 0; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
        piece[i][1] += 1;
      }
      for(i = 0; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
      }
    }
    break;

  }
  return ok;
}


SbBool
rotate_piece(short way)
{
  SbBool ok = TRUE;
  int i = 0;
  int d1 = 0;
  int c[] = {0, 0, 0};

  switch(way){
  case 0:
    for(i = 1; i < 4; i++){
      if(piece[i][2] > piece[0][2]){ // z
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 1;
          d1 = 2*(piece[i][2] - piece[0][2]);
          if(ok = !(piece[i][2] - d1 < 0)){
            if(!(ok = !room[piece[i][0]][piece[i][1]][piece[i][2] - d1])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 2;
          d1 = 2*(piece[0][0] - piece[i][0]);
          if(ok = !(piece[i][0] + d1 > 3)){
            if(!(ok = !room[piece[i][0] + d1][piece[i][1]][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 3;
          d1 = piece[i][2] - piece[0][2];
          if(ok = !(piece[i][0] + d1 > 3)){
            if(ok = !(piece[i][2] - d1 < 0)){
              if(!(ok = !room[piece[i][0] + d1][piece[i][1]][piece[i][2] - d1])) break;
            }
          }
          if(!ok) break;
        }
      }
      else if(piece[i][2] < piece[0][2]){ // z
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 4;
          d1 = 2*(piece[0][2] - piece[i][2]);
          if(ok = !(piece[i][0] - d1 < 0)){
            if(!(ok = !room[piece[i][0] - d1][piece[i][1]][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 5;
          d1 = 2*(piece[0][0] - piece[i][0]);
          if(ok = !(piece[i][2] + d1 > 13)){
            if(!(ok = !room[piece[i][0]][piece[i][1]][piece[i][2] + d1])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 6;
          d1 = piece[0][2] - piece[i][2];

          if(ok = !(piece[i][2] + d1 > 13)){
            if(ok = !(piece[i][0] - d1 < 0)){
              if(!(ok = !room[piece[i][0] - d1][piece[i][1]][piece[i][2] + d1])) break;
            }
          }
          if(!ok) break;
        }
      }
      else{
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 7;
          d1 = piece[i][0] - piece[0][0];
          if(ok = !(piece[i][0] - d1 < 0)){
            if(ok = !(piece[i][2] - d1 < 0)){
              if(!(ok = !room[piece[i][0] - d1][piece[i][1]][piece[i][2] - d1])) break;
            }
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 8;
          d1 = piece[0][0] - piece[i][0];
          if(ok = !(piece[i][2] + d1 > 13)){
            if(ok = !(piece[i][0] + d1 > 3)){
              if(!(ok = !room[piece[i][0] + d1][piece[i][1]][piece[i][2] + d1])) break;
            }
          }
          if(!ok) break;
        }
      }
    }

    if(ok){
      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
        switch(c[i-1]){
        case 1:
          d1 = 2*(piece[i][2] - piece[0][2]);
          piece[i][2] -= d1;
          break;
        case 2:
          d1 = 2*(piece[0][0] - piece[i][0]);
          piece[i][0] += d1;
          break;
        case 3:
          d1 = piece[i][2] - piece[0][2];
          piece[i][0] += d1;
          piece[i][2] -= d1;
          break;
        case 4:
          d1 = 2*(piece[0][2] - piece[i][2]);
          piece[i][0] -= d1;
          break;
        case 5:
          d1 = 2*(piece[0][0] - piece[i][0]);
          piece[i][2] += d1;
          break;
        case 6:
          d1 = piece[0][2] - piece[i][2];
          piece[i][0] -= d1;
          piece[i][2] += d1;
          break;
        case 7:
          d1 = piece[i][0] - piece[0][0];
          piece[i][0] -= d1;
          piece[i][2] -= d1;
          break;
        case 8:
          d1 = piece[0][0] - piece[i][0];
          piece[i][0] += d1;
          piece[i][2] += d1;
          break;
        }
      }
      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
      }
    }
    break;
  case 1:
    for(i = 1; i < 4; i++){
      if(piece[i][2] > piece[0][2]){ // z
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 1;
          d1 = 2*(piece[i][0] - piece[0][0]);
          if(ok = !(piece[i][0] - d1 < 0)){
            if(!(ok = !room[piece[i][0] - d1][piece[i][1]][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 2;
          d1 = 2*(piece[i][2] - piece[0][2]);
          if(ok = !(piece[i][2] - d1 < 0)){
            if(!(ok = !room[piece[i][0]][piece[i][1]][piece[i][2] - d1])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 3;
          d1 = piece[i][2] - piece[0][2];
          if(ok = !(piece[i][0] - d1 < 0)){
            if(ok = !(piece[i][2] - d1 < 0)){
              if(!(ok = !room[piece[i][0] - d1][piece[i][1]][piece[i][2] - d1])) break;
            }
          }
          if(!ok) break;
        }
      }
      else if(piece[i][2] < piece[0][2]){ // z
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 4;
          d1 = 2*(piece[0][2] - piece[i][2]);
          if(ok = !(piece[i][2] + d1 > 13)){
            if(!(ok = !room[piece[i][0]][piece[i][1]][piece[i][2] + d1])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 5;
          d1 = 2*(piece[0][0] - piece[i][0]);
          if(ok = !(piece[i][0] + d1 > 3)){
            if(!(ok = !room[piece[i][0] + d1][piece[i][1]][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 6;
          d1 = piece[0][2] - piece[i][2];
          if(ok = !(piece[i][2] + d1 > 13)){
            if(ok = !(piece[i][0] + d1 > 3)){
              if(!(ok = !room[piece[i][0] + d1][piece[i][1]][piece[i][2] + d1])) break;
            }
          }
          if(!ok) break;
        }
      }
      else{
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 7;
          d1 = piece[i][0] - piece[0][0];
          if(ok = !(piece[i][0] - d1 < 0)){
            if(ok = !(piece[i][2] + d1 > 13)){
              if(!(ok = !room[piece[i][0] - d1][piece[i][1]][piece[i][2] + d1])) break;
            }
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 8;
          d1 = piece[0][0] - piece[i][0];
          if(ok = !(piece[i][2] - d1 < 0)){
            if(ok = !(piece[i][0] + d1 > 3)){
              if(!(ok = !room[piece[i][0] + d1][piece[i][1]][piece[i][2] - d1])) break;
            }
          }
          if(!ok) break;
        }
      }
    }

    if(ok){
      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
        switch(c[i-1]){
        case 1:
          d1 = 2*(piece[i][0] - piece[0][0]);
          piece[i][0] -= d1;
          break;
        case 2:
          d1 = 2*(piece[i][2] - piece[0][2]);
          piece[i][2] -= d1;
          break;
        case 3:
          d1 = piece[i][2] - piece[0][2];
          piece[i][0] -= d1;
          piece[i][2] -= d1;
          break;
        case 4:
          d1 = 2*(piece[0][2] - piece[i][2]);
          piece[i][2] += d1;
          break;
        case 5:
          d1 = 2*(piece[0][0] - piece[i][0]);
          piece[i][0] += d1;
          break;
        case 6:
          d1 = piece[0][2] - piece[i][2];
          piece[i][0] += d1;
          piece[i][2] += d1;
          break;
        case 7:
          d1 = piece[i][0] - piece[0][0];
          piece[i][0] -= d1;
          piece[i][2] += d1;
          break;
        case 8:
          d1 = piece[0][0] - piece[i][0];
          piece[i][0] += d1;
          piece[i][2] -= d1;
          break;
        }
      }

      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
      }
    }
    break;

  case 2:
    for(i = 1; i < 4; i++){
      if(piece[i][1] > piece[0][1]){ // z
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 1;
          d1 = 2*(piece[i][1] - piece[0][1]);
          if(ok = !(piece[i][1] - d1 < 0)){
            if(!(ok = !room[piece[i][0]][piece[i][1] - d1][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 2;
          d1 = 2*(piece[0][0] - piece[i][0]);
          if(ok = !(piece[i][0] + d1 > 3)){
            if(!(ok = !room[piece[i][0] + d1][piece[i][1]][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 3;
          d1 = piece[i][1] - piece[0][1];
          if(ok = !(piece[i][0] + d1 > 3)){
            if(ok = !(piece[i][1] - d1 < 0)){
              if(!(ok = !room[piece[i][0] + d1][piece[i][1] - d1][piece[i][2]])) break;
            }
          }
          if(!ok) break;
        }
      }
      else if(piece[i][1] < piece[0][1]){ // z
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 4;
          d1 = 2*(piece[0][1] - piece[i][1]);
          if(ok = !(piece[i][0] - d1 < 0)){
            if(!(ok = !room[piece[i][0] - d1][piece[i][1]][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 5;
          d1 = 2*(piece[0][0] - piece[i][0]);
          if(ok = !(piece[i][1] + d1 > 3)){
            if(!(ok = !room[piece[i][0]][piece[i][1] + d1][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 6;
          d1 = piece[0][1] - piece[i][1];

          if(ok = !(piece[i][1] + d1 > 3)){
            if(ok = !(piece[i][0] - d1 < 0)){
              if(!(ok = !room[piece[i][0] - d1][piece[i][1] + d1][piece[i][2]])) break;
            }
          }
          if(!ok) break;
        }
      }
      else{
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 7;
          d1 = piece[i][0] - piece[0][0];
          if(ok = !(piece[i][0] - d1 < 0)){
            if(ok = !(piece[i][1] - d1 < 0)){
              if(!(ok = !room[piece[i][0] - d1][piece[i][1] - d1][piece[i][2]])) break;
            }
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 8;
          d1 = piece[0][0] - piece[i][0];
          if(ok = !(piece[i][1] + d1 > 3)){
            if(ok = !(piece[i][0] + d1 > 3)){
              if(!(ok = !room[piece[i][0] + d1][piece[i][1] + d1][piece[i][2]])) break;
            }
          }
          if(!ok) break;
        }
      }
    }

    if(ok){
      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
        switch(c[i-1]){
        case 1:
          d1 = 2*(piece[i][1] - piece[0][1]);
          piece[i][1] -= d1;
          break;
        case 2:
          d1 = 2*(piece[0][0] - piece[i][0]);
          piece[i][0] += d1;
          break;
        case 3:
          d1 = piece[i][1] - piece[0][1];
          piece[i][0] += d1;
          piece[i][1] -= d1;
          break;
        case 4:
          d1 = 2*(piece[0][1] - piece[i][1]);
          piece[i][0] -= d1;
          break;
        case 5:
          d1 = 2*(piece[0][0] - piece[i][0]);
          piece[i][1] += d1;
          break;
        case 6:
          d1 = piece[0][1] - piece[i][1];
          piece[i][0] -= d1;
          piece[i][1] += d1;
          break;
        case 7:
          d1 = piece[i][0] - piece[0][0];
          piece[i][0] -= d1;
          piece[i][1] -= d1;
          break;
        case 8:
          d1 = piece[0][0] - piece[i][0];
          piece[i][0] += d1;
          piece[i][1] += d1;
          break;
        }
      }
      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
      }
    }
    break;

  case 3:
    for(i = 1; i < 4; i++){
      if(piece[i][1] > piece[0][1]){ // z
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 1;
          d1 = 2*(piece[i][0] - piece[0][0]);
          if(ok = !(piece[i][0] - d1 < 0)){
            if(!(ok = !room[piece[i][0] - d1][piece[i][1]][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 2;
          d1 = 2*(piece[i][1] - piece[0][1]);
          if(ok = !(piece[i][1] - d1 < 0)){
            if(!(ok = !room[piece[i][0]][piece[i][1] - d1][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 3;
          d1 = piece[i][1] - piece[0][1];
          if(ok = !(piece[i][0] - d1 < 0)){
            if(ok = !(piece[i][1] - d1 < 0)){
              if(!(ok = !room[piece[i][0] - d1][piece[i][1] - d1][piece[i][2]])) break;
            }
          }
          if(!ok) break;
        }
      }
      else if(piece[i][1] < piece[0][1]){ // z
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 4;
          d1 = 2*(piece[0][1] - piece[i][1]);
          if(ok = !(piece[i][1] + d1 > 3)){
            if(!(ok = !room[piece[i][0]][piece[i][1] + d1][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 5;
          d1 = 2*(piece[0][0] - piece[i][0]);
          if(ok = !(piece[i][0] + d1 > 3)){
            if(!(ok = !room[piece[i][0] + d1][piece[i][1]][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 6;
          d1 = piece[0][1] - piece[i][1];
          if(ok = !(piece[i][1] + d1 > 3)){
            if(ok = !(piece[i][0] + d1 > 3)){
              if(!(ok = !room[piece[i][0] + d1][piece[i][1] + d1][piece[i][2]])) break;
            }
          }
          if(!ok) break;
        }
      }
      else{
        if(piece[i][0] > piece[0][0]){ // x
          c[i-1] = 7;
          d1 = piece[i][0] - piece[0][0];
          if(ok = !(piece[i][0] - d1 < 0)){
            if(ok = !(piece[i][1] + d1 > 3)){
              if(!(ok = !room[piece[i][0] - d1][piece[i][1] + d1][piece[i][2]])) break;
            }
          }
          if(!ok) break;
        }
        else if(piece[i][0] < piece[0][0]){
          c[i-1] = 8;
          d1 = piece[0][0] - piece[i][0];
          if(ok = !(piece[i][1] - d1 < 0)){
            if(ok = !(piece[i][0] + d1 > 3)){
              if(!(ok = !room[piece[i][0] + d1][piece[i][1] - d1][piece[i][2]])) break;
            }
          }
          if(!ok) break;
        }
      }
    }

    if(ok){
      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
        switch(c[i-1]){
        case 1:
          d1 = 2*(piece[i][0] - piece[0][0]);
          piece[i][0] -= d1;
          break;
        case 2:
          d1 = 2*(piece[i][1] - piece[0][1]);
          piece[i][1] -= d1;
          break;
        case 3:
          d1 = piece[i][1] - piece[0][1];
          piece[i][0] -= d1;
          piece[i][1] -= d1;
          break;
        case 4:
          d1 = 2*(piece[0][1] - piece[i][1]);
          piece[i][1] += d1;
          break;
        case 5:
          d1 = 2*(piece[0][0] - piece[i][0]);
          piece[i][0] += d1;
          break;
        case 6:
          d1 = piece[0][1] - piece[i][1];
          piece[i][0] += d1;
          piece[i][1] += d1;
          break;
        case 7:
          d1 = piece[i][0] - piece[0][0];
          piece[i][0] -= d1;
          piece[i][1] += d1;
          break;
        case 8:
          d1 = piece[0][0] - piece[i][0];
          piece[i][0] += d1;
          piece[i][1] -= d1;
          break;
        }
      }

      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
      }
    }
    break;
  case 5:
    for(i = 1; i < 4; i++){
      if(piece[i][2] > piece[0][2]){ // z
        if(piece[i][1] > piece[0][1]){ // x
          c[i-1] = 1;
          d1 = 2*(piece[i][2] - piece[0][2]);
          if(ok = !(piece[i][2] - d1 < 0)){
            if(!(ok = !room[piece[i][0]][piece[i][1]][piece[i][2] - d1])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][1] < piece[0][1]){
          c[i-1] = 2;
          d1 = 2*(piece[0][1] - piece[i][1]);
          if(ok = !(piece[i][1] + d1 > 3)){
            if(!(ok = !room[piece[i][0]][piece[i][1] + d1][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 3;
          d1 = piece[i][2] - piece[0][2];
          if(ok = !(piece[i][1] + d1 > 3)){
            if(ok = !(piece[i][2] - d1 < 0)){
              if(!(ok = !room[piece[i][0]][piece[i][1] + d1][piece[i][2] - d1])) break;
            }
          }
          if(!ok) break;
        }
      }
      else if(piece[i][2] < piece[0][2]){ // z
        if(piece[i][1] > piece[0][1]){ // x
          c[i-1] = 4;
          d1 = 2*(piece[0][2] - piece[i][2]);
          if(ok = !(piece[i][1] - d1 < 0)){
            if(!(ok = !room[piece[i][0]][piece[i][1] - d1][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][1] < piece[0][1]){
          c[i-1] = 5;
          d1 = 2*(piece[0][1] - piece[i][1]);
          if(ok = !(piece[i][2] + d1 > 13)){
            if(!(ok = !room[piece[i][0]][piece[i][1]][piece[i][2] + d1])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 6;
          d1 = piece[0][2] - piece[i][2];

          if(ok = !(piece[i][2] + d1 > 13)){
            if(ok = !(piece[i][1] - d1 < 0)){
              if(!(ok = !room[piece[i][0]][piece[i][1] - d1][piece[i][2] + d1])) break;
            }
          }
          if(!ok) break;
        }
      }
      else{
        if(piece[i][1] > piece[0][1]){ // x
          c[i-1] = 7;
          d1 = piece[i][1] - piece[0][1];
          if(ok = !(piece[i][1] - d1 < 0)){
            if(ok = !(piece[i][2] - d1 < 0)){
              if(!(ok = !room[piece[i][0]][piece[i][1] - d1][piece[i][2] - d1])) break;
            }
          }
          if(!ok) break;
        }
        else if(piece[i][1] < piece[0][1]){
          c[i-1] = 8;
          d1 = piece[0][1] - piece[i][1];
          if(ok = !(piece[i][2] + d1 > 13)){
            if(ok = !(piece[i][1] + d1 > 3)){
              if(!(ok = !room[piece[i][0]][piece[i][1] + d1][piece[i][2] + d1])) break;
            }
          }
          if(!ok) break;
        }
      }
    }

    if(ok){
      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
        switch(c[i-1]){
        case 1:
          d1 = 2*(piece[i][2] - piece[0][2]);
          piece[i][2] -= d1;
          break;
        case 2:
          d1 = 2*(piece[0][1] - piece[i][1]);
          piece[i][1] += d1;
          break;
        case 3:
          d1 = piece[i][2] - piece[0][2];
          piece[i][1] += d1;
          piece[i][2] -= d1;
          break;
        case 4:
          d1 = 2*(piece[0][2] - piece[i][2]);
          piece[i][1] -= d1;
          break;
        case 5:
          d1 = 2*(piece[0][1] - piece[i][1]);
          piece[i][2] += d1;
          break;
        case 6:
          d1 = piece[0][2] - piece[i][2];
          piece[i][1] -= d1;
          piece[i][2] += d1;
          break;
        case 7:
          d1 = piece[i][1] - piece[0][1];
          piece[i][1] -= d1;
          piece[i][2] -= d1;
          break;
        case 8:
          d1 = piece[0][1] - piece[i][1];
          piece[i][1] += d1;
          piece[i][2] += d1;
          break;
        }
      }
      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
      }
    }
    break;
  case 4:
    for(i = 1; i < 4; i++){
      if(piece[i][2] > piece[0][2]){ // z
        if(piece[i][1] > piece[0][1]){ // x
          c[i-1] = 1;
          d1 = 2*(piece[i][1] - piece[0][1]);
          if(ok = !(piece[i][1] - d1 < 0)){
            if(!(ok = !room[piece[i][0]][piece[i][1] - d1][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][1] < piece[0][1]){
          c[i-1] = 2;
          d1 = 2*(piece[i][2] - piece[0][2]);
          if(ok = !(piece[i][2] - d1 < 0)){
            if(!(ok = !room[piece[i][0]][piece[i][1]][piece[i][2] - d1])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 3;
          d1 = piece[i][2] - piece[0][2];
          if(ok = !(piece[i][1] - d1 < 0)){
            if(ok = !(piece[i][2] - d1 < 0)){
              if(!(ok = !room[piece[i][0]][piece[i][1] - d1][piece[i][2] - d1])) break;
            }
          }
          if(!ok) break;
        }
      }
      else if(piece[i][2] < piece[0][2]){ // z
        if(piece[i][1] > piece[0][1]){ // x
          c[i-1] = 4;
          d1 = 2*(piece[0][2] - piece[i][2]);
          if(ok = !(piece[i][2] + d1 > 13)){
            if(!(ok = !room[piece[i][0]][piece[i][1]][piece[i][2] + d1])) break;
          }
          if(!ok) break;
        }
        else if(piece[i][1] < piece[0][1]){
          c[i-1] = 5;
          d1 = 2*(piece[0][1] - piece[i][1]);
          if(ok = !(piece[i][1] + d1 > 3)){
            if(!(ok = !room[piece[i][0]][piece[i][1] + d1][piece[i][2]])) break;
          }
          if(!ok) break;
        }
        else{
          c[i-1] = 6;
          d1 = piece[0][2] - piece[i][2];
          if(ok = !(piece[i][2] + d1 > 13)){
            if(ok = !(piece[i][1] + d1 > 3)){
              if(!(ok = !room[piece[i][0]][piece[i][1] + d1][piece[i][2] + d1])) break;
            }
          }
          if(!ok) break;
        }
      }
      else{
        if(piece[i][1] > piece[0][1]){ // x
          c[i-1] = 7;
          d1 = piece[i][1] - piece[0][1];
          if(ok = !(piece[i][1] - d1 < 0)){
            if(ok = !(piece[i][2] + d1 > 13)){
              if(!(ok = !room[piece[i][0]][piece[i][1] - d1][piece[i][2] + d1])) break;
            }
          }
          if(!ok) break;
        }
        else if(piece[i][1] < piece[0][1]){
          c[i-1] = 8;
          d1 = piece[0][1] - piece[i][1];
          if(ok = !(piece[i][2] - d1 < 0)){
            if(ok = !(piece[i][1] + d1 > 3)){
              if(!(ok = !room[piece[i][0]][piece[i][1] + d1][piece[i][2] - d1])) break;
            }
          }
          if(!ok) break;
        }
      }
    }

    if(ok){
      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(1.0);
        switch(c[i-1]){
        case 1:
          d1 = 2*(piece[i][1] - piece[0][1]);
          piece[i][1] -= d1;
          break;
        case 2:
          d1 = 2*(piece[i][2] - piece[0][2]);
          piece[i][2] -= d1;
          break;
        case 3:
          d1 = piece[i][2] - piece[0][2];
         piece[i][1] -= d1;
          piece[i][2] -= d1;
          break;
        case 4:
          d1 = 2*(piece[0][2] - piece[i][2]);
          piece[i][2] += d1;
          break;
        case 5:
          d1 = 2*(piece[0][1] - piece[i][1]);
          piece[i][1] += d1;
          break;
        case 6:
          d1 = piece[0][2] - piece[i][2];
          piece[i][1] += d1;
          piece[i][2] += d1;
          break;
        case 7:
          d1 = piece[i][1] - piece[0][1];
          piece[i][1] -= d1;
          piece[i][2] += d1;
          break;
        case 8:
          d1 = piece[0][1] - piece[i][1];
          piece[i][1] += d1;
          piece[i][2] -= d1;
          break;
        }
      }

      for(i = 1; i < 4; i++){
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
        roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
      }
    }
    break;

  }

  return ok;
}

void
remove_planes()
{
  short planes[] = {-1,-1,-1,-1};
  short planes2[] = {-1,-1,-1,-1};
  short movers[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  short numplanes = 0;
  SoMaterial * tempmat = new SoMaterial;
  tempmat->ref();
  SbBool full;
  full = TRUE;

  int i;
  for(i = 0; i < 14; i++){
    full = TRUE;
    for(int j = 0; j < 4; j++){
      for(int k = 0; k < 4; k++){
        if(!room[k][j][i]){
          full = FALSE;
          break;
        }
      }
      if(!full){
        break;
      }
    }
    if(full){
      planes[numplanes] = i;
      numplanes++;
      if(numplanes == 4) break;
    }
  }

  if(numplanes > 0){

    numplanes = 1;
    planes2[0] = planes[0];

    for(i = 1; i < 4; i++){
      if(planes[i] == -1) break;
      if(planes[i] == planes[i-1]) continue;
      planes2[numplanes] = planes[i];
      numplanes++;
    }

    for(i = 0; i < numplanes; i++){
      for(int j = 0; j < 4; j++){
        for(int k = 0; k < 4; k++){
          roommaterials[k][j][planes2[i]]->transparency.setValue(1.0);
          room[k][j][planes2[i]] = FALSE;
        }
      }
    }

    short plnum = 1;
    short temp = 1;
    int j = 1;
    SbBool t = TRUE;
    (void)printf("1 \n");
    if(planes2[1] < 0){
      for(i = planes2[0] + 1; i < 14; i++){
        for(int j = 0; j < 4; j++){
          for(int k = 0; k < 4; k++){
            if(room[k][j][i]){
              room[k][j][i] = FALSE;
              roommaterials[k][j][i]->transparency.setValue(1.0);
              tempmat->ambientColor = roommaterials[k][j][i]->ambientColor;
              roommaterials[k][j][i - plnum]->ambientColor = tempmat->ambientColor;
              room[k][j][i - plnum] = TRUE;
              roommaterials[k][j][i - plnum]->transparency.setValue(0.0);
            }
          }
        }
      }
    }
    else{
      for(i = planes2[0] + 1; i < 14; i++){

        if(j < numplanes & planes2[j] == i){
          j++;
          plnum++;
        }
        else{
          for(int j = 0; j < 4; j++){
            for(int k = 0; k < 4; k++){
              if(room[k][j][i]){
                room[k][j][i] = FALSE;
                roommaterials[k][j][i]->transparency.setValue(1.0);
                tempmat->ambientColor = roommaterials[k][j][i]->ambientColor;
                roommaterials[k][j][i - plnum]->ambientColor = tempmat->ambientColor;
                room[k][j][i - plnum] = TRUE;
                roommaterials[k][j][i - plnum]->transparency.setValue(0.0);
              }
            }
          }

        }
        (void)printf("numplanes = %d, j = %d, plnum = %d\n", numplanes, j, plnum);
      }
    }
    lines1 += numplanes;
    lines2 = SbString(lines1);
    lines3->setValue(lines2.getString());
  }
  tempmat->unref();
}

SbBool
create_piece()
{
  SbBool ok = TRUE;
  SbTime *time = new SbTime;
  time->setToTimeOfDay();
  unsigned long piecetype = (time->getMsecValue())%5;

  int i = 0;

  //int piecetype = 2;
  switch(piecetype){
    case 0:
    piecet = 0;

    piece[0][0] = 1;
    piece[0][1] = 1;
    piece[0][2] = 11;

    piece[1][0] = 1;
    piece[1][1] = 1;
    piece[1][2] = 12;

    piece[2][0] = 1;
    piece[2][1] = 1;
    piece[2][2] = 13;

    piece[3][0] = 1;
    piece[3][1] = 1;
    piece[3][2] = 10;

    piecematerial->ambientColor.setValue(0,1,0);

    break;

    case 1:
    piecet = 1;

    piece[0][0] = 1;
    piece[0][1] = 1;
    piece[0][2] = 13;

    piece[1][0] = 1;
    piece[1][1] = 2;
    piece[1][2] = 13;

    piece[2][0] = 1;
    piece[2][1] = 1;
    piece[2][2] = 12;

    piece[3][0] = 1;
    piece[3][1] = 2;
    piece[3][2] = 12;

    piecematerial->ambientColor.setValue(1,0,0);

    break;

    case 2:
    piecet = 2;

    piece[0][0] = 1;
    piece[0][1] = 1;
    piece[0][2] = 12;

    piece[1][0] = 2;
    piece[1][1] = 1;
    piece[1][2] = 13;

    piece[2][0] = 1;
    piece[2][1] = 1;
    piece[2][2] = 13;

    piece[3][0] = 1;
    piece[3][1] = 1;
    piece[3][2] = 11;

    piecematerial->ambientColor.setValue(1,1,1);

    break;

  case 3:
     piecet = 3;

    piece[0][0] = 1;
    piece[0][1] = 1;
    piece[0][2] = 12;

    piece[1][0] = 1;
    piece[1][1] = 1;
    piece[1][2] = 13;

    piece[2][0] = 2;
    piece[2][1] = 1;
    piece[2][2] = 12;

    piece[3][0] = 0;
    piece[3][1] = 1;
    piece[3][2] = 12;

    piecematerial->ambientColor.setValue(0,0,1);

    break;

  case 4:
    piecet = 4;

    piece[0][0] = 1;
    piece[0][1] = 1;
    piece[0][2] = 12;

    piece[1][0] = 1;
    piece[1][1] = 1;
    piece[1][2] = 13;

    piece[2][0] = 2;
    piece[2][1] = 1;
    piece[2][2] = 12;

    piece[3][0] = 2;
    piece[3][1] = 1;
    piece[3][2] = 11;

    piecematerial->ambientColor.setValue(1,0,1);

    break;
  }
  for (; i < 4; i++){
    if(!room[piece[i][0]][piece[i][1]][piece[i][2]]){
      roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->ambientColor = piecematerial->ambientColor;
      roommaterials[piece[i][0]][piece[i][1]][piece[i][2]]->transparency.setValue(0.0);
    }
    else{
      ok = FALSE;
      break;
    }

  }

  return ok;

}


void
event_cb(void *userdata, SoEventCallback *node)
{

  const SoEvent *event = node->getEvent();
  //move left
  if (SO_KEY_PRESS_EVENT(event, LEFT_ARROW)) {
    translate_piece(0);
  }
  //move right
  else if (SO_KEY_PRESS_EVENT(event, RIGHT_ARROW)) {
    translate_piece(1);
  }
  //move forward
  else if (SO_KEY_PRESS_EVENT(event, UP_ARROW)) {
    translate_piece(2);
  }
  //move backward
  else if (SO_KEY_PRESS_EVENT(event, DOWN_ARROW)) {
    translate_piece(3);
  }
  //drop
  else if (SO_KEY_PRESS_EVENT(event, SPACE)) {
    if(!lower_piece()){
      remove_planes();
      if(!create_piece()) exit(1);
    }
  }
  //yaw forward
  else if (SO_KEY_PRESS_EVENT(event, W)) {
    if(!rotate_piece(0));
  }
  //yaw backward
  else if (SO_KEY_PRESS_EVENT(event, S)) {
    if(!rotate_piece(1));
  }
  //rotate left
  else if (SO_KEY_PRESS_EVENT(event, A)) {
    if(!rotate_piece(2));
  }
  //rotate right
  else if (SO_KEY_PRESS_EVENT(event, D)) {
    if(!rotate_piece(3));
  }
  //roll left
  else if (SO_KEY_PRESS_EVENT(event, Q)) {
    if(!rotate_piece(4));
  }
  //roll right
  else if (SO_KEY_PRESS_EVENT(event, E)) {
    if(!rotate_piece(5));
  }
  else if (SO_KEY_PRESS_EVENT(event, X)) {
    exit(1);
  }

}

void
time_cb(void *userdata, SoSensor *)
{
  if(!lower_piece()){
    remove_planes();
    if(!create_piece()) exit(1);
  }
}

int
main(int argc, char **argv)
{
  @WIDGET@ window = So@Gui@::init(argv[0]);
  if (window == NULL) exit(1);

  SoSeparator * root = new SoSeparator;
  SoSeparator * gameroot = new SoSeparator;
  root->ref();
  gameroot->ref();

  SoPerspectiveCamera * gamecam = new SoPerspectiveCamera;
  gameroot->addChild(gamecam);

  SoDirectionalLight *light= new SoDirectionalLight;
  light->direction.setValue(-1,-1,-1);
  gameroot->addChild(light);

  SoEventCallback *cb = new SoEventCallback;
  cb->addEventCallback(SoKeyboardEvent::getClassTypeId(), event_cb, NULL);
  gameroot->insertChild(cb, 0);

  gameroot->addChild(create_room());
  gameroot->addChild(init_game());

  SbViewportRegion reg(500,500);

  SbVec3f pa(0,0,0);

  gamecam->position.setValue(0,14,2);
  gamecam->pointAt(pa);
  gamecam->viewAll(gameroot, reg);

  root->addChild(gameroot);

   // New camera for the instructions

  SoSeparator * instruction = new SoSeparator;
  instruction->ref();
  root->addChild(instruction);

  SoPerspectiveCamera * instrcam = new SoPerspectiveCamera;
  instruction->addChild(instrcam);

  // To make it render in a custom viewport
  SoCallback *vpcb = new SoCallback();
  vpcb->setCallback(setViewportCB, NULL);
  instruction->addChild(vpcb);

  SoTranslation * instrtrans = new SoTranslation;
  instrtrans->translation.setValue(7,-5.25,0);
  //instruction->addChild(instrtrans);

  SoText2 * text = new SoText2;
  SoText2 * score = new SoText2;
  const char * str[] = {
    "","SPACE drops current piece",
    "Arrows move piece left, right,", "forward and backward",
    "(not adjusted to eventual rotation", "by the user)",
    "W and S for forward and backward roll",
    "Q and E for left and right roll",
    "A and D for left and right rotation",
    "Press X to end Blocks","",
    "Planes completed ="
  };
  score->string.connectFrom(lines3);
  text->string.setValues(0, sizeof(str) / sizeof(char *), str);
  text->justification = SoText2::LEFT;
  instruction->addChild(text);
  instruction->addChild(instrtrans);
  instruction->addChild(score);
  root->addChild(instruction);

  SbViewportRegion reg2(245,250);
  instrcam->viewAll(instruction,reg2);

  create_piece();

  // Sets up the examiner viewer

  So@Gui@ExaminerViewer * viewer = new So@Gui@ExaminerViewer(window);
  viewer->setSceneGraph(root);
  viewer->setTitle("Blocks");
  viewer->setViewing(FALSE);

  SoTimerSensor * ts = new SoTimerSensor(time_cb, NULL);
  ts->setInterval(1);
  ts->schedule();

  viewer->show();

  So@Gui@::show(window);

  So@Gui@::mainLoop();

  delete viewer;
  piecematerial->unref();
  root->unref();
  gameroot->unref();
  instruction->unref();
  delete lines3;
  delete ts;
  return 0;

}
